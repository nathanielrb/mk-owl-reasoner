;; (define (subo a b subsets)
;;   (conde ((== a b))
;;          ((membero `(,a ,b) subsets))
;;          ((fresh (q r)
;;            (=/= q r)
;;            (== a `(U ,q ,r))
;;            (subo q b subsets)
;;            (subo r b subsets)))
;;          ((fresh (q r)
;;            (=/= q r)
;;            (== b `(U ,q ,r))
;;            (conde ((subo q b subsets))
;;                   ((subo r b subsets)))))
;;          ;; ??
;;          ;; ((fresh (q r)
;;          ;;   (== a `(A ,q ,r))
;;          ;;   (subo a q)
;;          ;;   (subo a r)))
;;          ((fresh (q r)
;;            (=/= q r)
;;            (== b `(A ,q ,r))
;;            (subo a q subsets)
;;            (subo a r subsets)))
;;          ((fresh (x)
;;            (membero `(,a ,x) subsets)
;;            (subo x b subsets)))))

;; (define (subclasso P Q)
;;   (fresh (a b c ;d e
;;             x y z ; q r
;;             )
;;          (== P `((spl:hasData ,a) (spl:hasPurpose ,b) (spl:hasProcessing ,c))) ; (Storage s1 s2)
;;          (== Q `((spl:hasData ,x) (spl:hasPurpose ,y) (spl:hasProcessing ,z))) ; (spl:hasRecipient ,q) (spl:hasStorage (,r1 ,r2))
;;          (subo a x datatypes)
;;          (subo b y purposes)
;;          (subo c z operations)
;;          ;; recipient
;;          ;; (subseto c z storage)
;;          ))
    
